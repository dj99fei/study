#存储管理

###虚拟地址和虚拟地址空间

内存中同时存在多个进程，每个进程的地址都是以0地址作为起始地址的虚拟地址空间，这个虚地址空间可以是线性的（一维的），也可以是多维的，这要取决于系统采用的存储管理方式。进程中的每一个指令和数据在这样的虚地址空间中都有一个惟一确定的地址，即虚拟地址。

每一个进程都具有各自独立的虚拟地址空间，而整个系统只有一个物理地址空间。任何一个要执行的进程，都必须进入真正的内存中，在内存的物理空间中存在，这就需要在虚拟地址空间和物理地址空间之间建立适当的映射关系。通过这种映射关系，逐部分地把存在于虚拟地址空间中的进程要执行的。

部分放在物理地址空间中，而其他暂时不执行的部分放在外部存储器中，内外存动态地传递数据，最终完成整个进程所执行的任务。这种映射，也称为地址变换，是操作系统在硬件的配合下实现的。

###内存管理方式

######页

把进程的虚拟地址空间划分为大小相等的部分，每一部分称为页（page），同时把物理内存空间也按照页的大小划分为小的部分，称为页面（page frame，也称为页架，页框）。对于80386体系，页和页面的大小都是4k字节。

在页和页面之间建立一一映射关系，连续的一维虚拟地址空间可以分别存放在不同的物理空间中，因此，物理存储中，每个页面内部地址连续，而页面之间的地址可以是连续的。页和页面之间的映射关系记录在一个表格中，这样的表格称为也表。每一个进程使用唯一的页表，页表的每一项数据称为页表项，表示虚拟空间中某一页和实际物理空间中某一页面的对应关系，页表也存储在物理空间内

![image](https://github.com/dj99fei/study/blob/master/os/images/169C5A42-7A63-4EF7-B5F7-397E16A44424.png?raw=true)

管理过程中，内外存的数据传递是以页为单位。

利用分页技术将一维连续虚拟空间划分为一个个页，进程的虚拟地址有两部分组成：页号P和页内地址（偏移地址）W。这两个部分的虚拟地址经过地址变换后，映射到物理内存的对应单元。具体变换过程如下图：

![image](https://github.com/dj99fei/study/blob/master/os/images/169C5A42-7A63-4EF7-B5F7-397E16A44425.png?raw=true)

操作系统为每一个进程维护一个独立的页表，进程正在执行的时候，页表信息记录在页表控制寄存器中，系统根据寄存器的值得到该进程对应页表的地址，同时利用页号，就可以得到该页对应的页表项。查找页表，获得了页表所映射的页面号，由页面号和内存地址，就可以直接找到内存中的对应存储单元。

在整个变换过程中，需要两次访问内存。第一次查页表，第二次取数据。为了提高效率，硬件一般提供一个高速的联想寄存器，构成一个快表（translation lookaside buffer），把当前进程中经常使用的页表放在快表，地址变换过程中，首先访问快表，同时去访问内存，如果快表中有，直接拿来用，停止去查内存中的页表。注意是lookaside

采用页式管理，实现了进程的程序和数据非连续存放，对内存和外存统一管理，得到更大的虚拟存储空间，可以同时容纳和运行更多的的进程，有利于系统整体性能的提高。缺点是增加了系统的开销，而且需要一定的硬件支持。由于虚拟空间是连续的，整个进程按照一维地址顺序排列，同一个程序段在分页的过程中，可能分别位于不同的页中，代码和数据的共享比较空难。


###段

段式管理的基本思想是把整个程序按照逻辑结构划分为不同的段，每个段可以是一个函数或者数据（data segment、code segment），由用户自己指定。大小当然可以不同。所以，在用户角度段下的地址是二维的：段地址和段内偏移地址。

段式和页式的比较：

它们都解决了程序不连续存储，从而减少了内存碎片。其中页式是把物理内存和程序的逻辑内存等大的切割，由系统完成，它消除外碎片，但是每个页内不一定全部使用，所以仍然有内碎片。在用户角度，地址访问是一维的。段式是用户来划定每个段的大小，所以它能够保证逻辑上的连续性。它可以消除内碎片，但是不能消除外碎片，可以通过内存紧缩的方式来减少外碎片。在用户角度，地址访问是二维的。页式和段式管理过程中的地址转化都是有硬件来协助完成的。比如，在段式中，
	mov ax，4000h
	mov ss,ax
	mov sp,02
	push ax
以上指令仅仅为设置相关寄存器的值，然后cpu会自动从寄存器中取相关参数，然后自动转化地址。 
