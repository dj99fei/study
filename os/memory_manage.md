#存储管理

###虚拟地址和虚拟地址空间

内存中同时存在多个进程，每个进程的地址都是以0地址作为起始地址的虚拟地址空间，这个虚地址空间可以是线性的（一维的），也可以是多维的，这要取决于系统采用的存储管理方式。进程中的每一个指令和数据在这样的虚地址空间中都有一个惟一确定的地址，即虚拟地址。

每一个进程都具有各自独立的虚拟地址空间，而整个系统只有一个物理地址空间。任何一个要执行的进程，都必须进入真正的内存中，在内存的物理空间中存在，这就需要在虚拟地址空间和物理地址空间之间建立适当的映射关系。通过这种映射关系，逐部分地把存在于虚拟地址空间中的进程要执行的。

部分放在物理地址空间中，而其他暂时不执行的部分放在外部存储器中，内外存动态地传递数据，最终完成整个进程所执行的任务。这种映射，也称为地址变换，是操作系统在硬件的配合下实现的。

###内存管理方式

######页

把进程的虚拟地址空间划分为大小相等的部分，每一部分称为页（page），同时把物理内存空间也按照页的大小划分为小的部分，称为页面（page frame，也称为页架，页框）。对于80386体系，页和页面的大小都是4k字节。

在页和页面之间建立一一映射关系，连续的一维虚拟地址空间可以分别存放在不同的物理空间中，因此，物理存储中，每个页面内部地址连续，而页面之间的地址可以是连续的。页和页面之间的映射关系记录在一个表格中，这样的表格称为也表。每一个进程使用唯一的页表，页表的每一项数据称为页表项，表示虚拟空间中某一页和实际物理空间中某一页面的对应关系，页表也存储在物理空间内

![image](https://github.com/dj99fei/study/blob/master/os/images/169C5A42-7A63-4EF7-B5F7-397E16A44424.png?raw=true)

管理过程中，内外存的数据传递是以页为单位。

利用分页技术将一维连续虚拟空间划分为一个个页，进程的虚拟地址有两部分组成：页号P和页内地址（偏移地址）W。这两个部分的虚拟地址经过地址变换后，映射到物理内存的对应单元。具体变换过程如下图：

![image](https://github.com/dj99fei/study/blob/master/os/images/169C5A42-7A63-4EF7-B5F7-397E16A44425.png?raw=true)

操作系统为每一个进程维护一个独立的页表，进程正在执行的时候，页表信息记录在页表控制寄存器中，系统根据寄存器的值得到该进程对应页表的地址，同时利用页号，就可以得到该页对应的页表项。查找页表，获得了页表所映射的页面号，由页面号和内存地址，就可以直接找到内存中的对应存储单元。

在整个变换过程中，需要两次访问内存。第一次查页表，第二次取数据。为了提高效率，硬件一般提供一个高速的联想寄存器，构成一个快表（translation lookaside buffer），把当前进程中经常使用的页表放在快表，地址变换过程中，首先访问快表，同时去访问内存，如果快表中有，直接拿来用，停止去查内存中的页表。注意是lookaside

采用页式管理，实现了进程的程序和数据非连续存放，对内存和外存统一管理，得到更大的虚拟存储空间，可以同时容纳和运行更多的的进程，有利于系统整体性能的提高。缺点是增加了系统的开销，而且需要一定的硬件支持。由于虚拟空间是连续的，整个进程按照一维地址顺序排列，同一个程序段在分页的过程中，可能分别位于不同的页中，代码和数据的共享比较空难。


###段

段式管理的基本思想是把整个程序按照逻辑结构划分为不同的段，每个段可以是一个函数或者数据（data segment、code segment），由用户自己指定。大小当然可以不同。所以，在用户角度段下的地址是二维的：段地址和段内偏移地址。

**段式和页式的比较**

它们都解决了程序不连续存储，从而减少了内存碎片。其中页式是把物理内存和程序的逻辑内存等大的切割，由系统完成，它消除外碎片，但是每个页内不一定全部使用，所以仍然有内碎片。在用户角度，地址访问是一维的。段式是用户来划定每个段的大小，所以它能够保证逻辑上的连续性。它可以消除内碎片，但是不能消除外碎片，可以通过内存紧缩的方式来减少外碎片。在用户角度，地址访问是二维的。页式和段式管理过程中的地址转化都是有硬件来协助完成的。比如，在段式中，

	mov ax，4000h
	mov ss,ax
	mov sp,02
	push ax

以上指令仅仅设置了相关寄存器的值，然后cpu会自动从寄存器中取相关参数，然后自动转化地址。 

####段页式

段页式存储管理，综合利用段式和页式管理的思想，把整个二维虚拟空间先分段，然后在段内分页。以页为最小的存储管理单位来实现虚拟存储。一方面可以按照程序的逻辑关系来划分进程空间的段，另一方面使用页来存放每一个段的内容，内外存交换以统一格式和大小的页来进行。

段页式的地址包括三个部分：段号、页号、页内偏移地址。转化过程要经过两次。所以开销大，实现复杂。

**80386段页机制**

80386是Intel公司推出的32位CISC芯片，有两种工作模式，实地址模式和虚拟地址模式，后者又被称为保护模式。实地址模式跟早起的8086兼容，不能启用分页机制，不区分特权级，分段机制也受到限制，直接寻址方式，只能寻址1MB。

I386的保护模式支持分段机制，整个虚拟空间可以划分为16K个段，每个段大小可变，最大能达到4GB，每个段可以提供独立的段内保护，支持二级分页机制，每个页面4KB，提供段页式存储管理的硬件支持。同时，在同一个任务内部，还提供4种（0~3）保护特权级，某一级特权i只可以访问所有其他大于等于这一特权级（>=i）的程序段。

**I386中段页式管理的硬件支持**

在存储过程中，要经过相对独立的两级地址变换。第一级使用分段机制，把包含段地址和段内偏移地址的二维虚拟地址空间转换为一个线性地址空间（也是虚拟地址空间），第二级使用分页机制，把线性地址空间转换为物理地址空间。这种转换关系可以用下图描述。

![image](https://github.com/dj99fei/study/blob/master/os/images/9B57F39B-619F-4833-9C62-B322BC853797.png?raw=true)

线性地址（虚拟地址）是一个无符号的整数，比如8086cpu中它是个32位的无符号整数，可以表示高达4GB的地址。线性地址通常用16机制数字表示，8086cpu中值的范围从0x00000000到0xffffffff。

物理地址是用于内存芯片级内存单元寻址。它们与从cpu的地址引脚发送到内存总线上的电信号相对应。

内存控制单元（MMU）通过一种称为分段单元（segmentation unit）的硬件电路把一个逻辑地址转换为线性地址，接着，第二个称为分页单元（paging unit）的硬件电路把线性地址转换为一个物理地址。如下图

![image](https://github.com/dj99fei/study/blob/master/os/images/AB45F47D-FCD2-493D-8CA3-D5B206B7091A.png?raw=true)

注：保护模式最早出现于286。

二维虚拟地址空间到线性地址空间的转化由段描述符表（简称段表）来描述，段表的每一个数据项纪录一个段到线性地址的关系，段表存放在线性地址空间中。线性地址空间到物理地址空间的转化由页表描述，页表存放在物理地址空间中。

每个段由一个8字节的段描述符（segment description）表示，它描述了段的特征。段描述符放在全局描述符表（Global Descriptor Table，GDT）或局部描述符表（Local Descriptor Table，LDT）中。

通常制定一个GDT，而每个进程除了存放在GDT中的段之外如果还需要创建附加的段，就可以偶自己的LDT。GDT在主存中的地址和大小存放在gdtr控制寄存器中，当前正在使用的LDT地址和大小放在ldtr控制寄存器中。

**段描述符字段**

<table>
<tr>
<td>字段名</td>
<td>描述</td>
</tr>
<tr>
<td>Base</td>
<td>包含段的首字节的线性地址</td>
</tr>
<tr>
<td>G</td>
<td>粒度标志：如果该位清0，则段大小以字节为单位，否则以4096字节的倍数计</td>
</tr>
<tr>
<td>Limit</td>
<td>存放段中的最后一个内存单元的偏移量，从而决定段的长度。如果G被置为0，则一个段的大小在1个字节到1MB之间变化；否则，将在4KB到4GB之间变化</td>
</tr>
<tr>
<td>S</td>
<td>系统标志：如果被清0，则这个系统段，存储诸如LDT这类关键的数据结构，否则它是一个普通的代码段或数据段</td>
</tr>
<tr>
<td>Type</td>
<td>描述了段的类型特征和它的存取权限</td>
</tr>
<tr>
<td>DPL</td>
<td>描述符特权级（Descriptor Privilege Level）字段：用于限制对这个段的存取。它表示为访问这个段而要求的CPU最小的优先级。因此，DPL设置为0的段只能当CPL为0（即内核态）才是可以访问的，而DPL设为3的段对任何CPL值都是可访问的</td>
</tr>
<tr>
<td>P</td>
<td>Segment-Present标志：等于0表示段当前不在主存。linux总是把这个标志（第47位）设为1，因为它从来不把整个段交换到磁盘上去</td>
</tr>
<tr>
<td>D或B</td>
<td>称为D或B的标志，取决于是代码段还是数据段。D或B的含义在两种情况下稍微有点区别，但是如果段偏移量的地址是32位长，就基本上把它置为1，如果这个偏移量是16位长，它被清0</td>
</tr>
<tr>
<td>AVL标志</td>
<td>可以由操作系统使用，但是被linux忽略</td>
</tr>
</table>

系统中所有进程共享一个GDT，而每一个进程都有自己的LDT。当进程发生切换时，GDT不变，而LDT更新为当前正在执行进程的LDT，因此，所有进程共享GDT所映射的物理地址空间，每一个进程都有自己单独的地址空间（由LDT描述）。

线性地址空间划分为大小相等的页，每页为4KB，与之对应的物理地址空间划分为大小相等的页面，页面的大小也是4KB。I386体系结构采用二级分页机制，线性地址到物理地址的映射使用一个二级页表，二级表中的第一级称为页目录，每个页目录项指向一个二级表，这个二级表就是页表，每一个表项记录该表对应的表架的基地址，这个基地址和偏移量一起就构成了整个物理地址。

每当一个段选择符被装入段寄存器时，相应的段描述符（8个字节）就由内存装入到对应的非编程cpu寄存器。


**分段单元**

![image](https://github.com/dj99fei/study/blob/master/os/images/194F7065-18F8-45D7-810F-59665397170A.png?raw=true)

上图详细显示了一个逻辑地址是怎么转换为相应的线性地址的。分段单元（segmentation unit）执行以下操作：

* 先检查段选择符的TI字段，以决定段选择符保存在哪个一描述附表中。TI字段指明了描述符在GDT中（在这种情况下，分段单元从gdtr寄存器中得到GDT的线性基地址）还是在激活的LDT中（这种情况下，分段段元从ldtr寄存器中得到LDT的线性基地址)。
* 从段选择符的index字段计算段描述符的地址，index字段的值乘以8（一个段描述符的大小），这个结构与gdtr或ldtr寄存器中的内容相加。
* 把逻辑地址的偏移量与段描述符中Base字段的值相加就得到线性地址。
