#存储管理

###虚拟地址和虚拟地址空间

内存中同时存在多个进程，每个进程的地址都是以0地址作为起始地址的虚拟地址空间，这个虚地址空间可以是线性的（一维的），也可以是多维的，这要取决于系统采用的存储管理方式。进程中的每一个指令和数据在这样的虚地址空间中都有一个惟一确定的地址，即虚拟地址。

每一个进程都具有各自独立的虚拟地址空间，而整个系统只有一个物理地址空间。任何一个要执行的进程，都必须进入真正的内存中，在内存的物理空间中存在，这就需要在虚拟地址空间和物理地址空间之间建立适当的映射关系。通过这种映射关系，逐部分地把存在于虚拟地址空间中的进程要执行的。

部分放在物理地址空间中，而其他暂时不执行的部分放在外部存储器中，内外存动态地传递数据，最终完成整个进程所执行的任务。这种映射，也称为地址变换，是操作系统在硬件的配合下实现的。

###内存管理方式

######页

把进程的虚拟地址空间划分为大小相等的部分，每一部分称为页（page），同时把物理内存空间也按照页的大小划分为小的部分，称为页面（page frame，也称为页架，页框）。对于80386体系，页和页面的大小都是4k字节。

在页和页面之间建立一一映射关系，连续的一维虚拟地址空间可以分别存放在不同的物理空间中，因此，物理存储中，每个页面内部地址连续，而页面之间的地址可以是连续的。页和页面之间的映射关系记录在一个表格中，这样的表格称为也表。每一个进程使用唯一的页表，页表的每一项数据称为页表项，表示虚拟空间中某一页和实际物理空间中某一页面的对应关系，页表也存储在物理空间内

![image](https://github.com/dj99fei/study/blob/master/os/images/169C5A42-7A63-4EF7-B5F7-397E16A44424.png?raw=true)

管理过程中，内外存的数据传递是以页为单位。

利用分页技术将一维连续虚拟空间划分为一个个页，进程的虚拟地址有两部分组成：页号P和页内地址（偏移地址）W。这两个部分的虚拟地址经过地址变换后，映射到物理内存的对应单元。具体变换过程如下图：

![image](https://github.com/dj99fei/study/blob/master/os/images/169C5A42-7A63-4EF7-B5F7-397E16A44425.png?raw=true)

操作系统为每一个进程维护一个独立的页表，进程正在执行的时候，页表信息记录在页表控制寄存器中，系统根据寄存器的值得到该进程对应页表的地址，同时利用页号，就可以得到该页对应的页表项。查找页表，获得了页表所映射的页面号，由页面号和内存地址，就可以直接找到内存中的对应存储单元。

在整个变换过程中，需要两次访问内存。第一次查页表，第二次取数据。为了提高效率，硬件一般提供一个高速的联想寄存器，构成一个快表（translation lookaside buffer），把当前进程中经常使用的页表放在快表，地址变换过程中，首先访问快表，同时去访问内存，如果快表中有，直接拿来用，停止去查内存中的页表。注意是lookaside

采用页式管理，实现了进程的程序和数据非连续存放，对内存和外存统一管理，得到更大的虚拟存储空间，可以同时容纳和运行更多的的进程，有利于系统整体性能的提高。缺点是增加了系统的开销，而且需要一定的硬件支持。由于虚拟空间是连续的，整个进程按照一维地址顺序排列，同一个程序段在分页的过程中，可能分别位于不同的页中，代码和数据的共享比较空难。


###段

段式管理的基本思想是把整个程序按照逻辑结构划分为不同的段，每个段可以是一个函数或者数据（data segment、code segment），由用户自己指定。大小当然可以不同。所以，在用户角度段下的地址是二维的：段地址和段内偏移地址。

**段式和页式的比较**

它们都解决了程序不连续存储，从而减少了内存碎片。其中页式是把物理内存和程序的逻辑内存等大的切割，由系统完成，它消除外碎片，但是每个页内不一定全部使用，所以仍然有内碎片。在用户角度，地址访问是一维的。段式是用户来划定每个段的大小，所以它能够保证逻辑上的连续性。它可以消除内碎片，但是不能消除外碎片，可以通过内存紧缩的方式来减少外碎片。在用户角度，地址访问是二维的。页式和段式管理过程中的地址转化都是有硬件来协助完成的。比如，在段式中，

	mov ax，4000h
	mov ss,ax
	mov sp,02
	push ax

以上指令仅仅设置了相关寄存器的值，然后cpu会自动从寄存器中取相关参数，然后自动转化地址。 

####段页式

段页式存储管理，综合利用段式和页式管理的思想，把整个二维虚拟空间先分段，然后在段内分页。以页为最小的存储管理单位来实现虚拟存储。一方面可以按照程序的逻辑关系来划分进程空间的段，另一方面使用页来存放每一个段的内容，内外存交换以统一格式和大小的页来进行。

段页式的地址包括三个部分：段号、页号、页内偏移地址。转化过程要经过两次。所以开销大，实现复杂。

**80386段页机制**

80386是Intel公司推出的32位CISC芯片，有两种工作模式，实地址模式和虚拟地址模式，后者又被称为保护模式。实地址模式跟早起的8086兼容，不能启用分页机制，不区分特权级，分段机制也受到限制，直接寻址方式，只能寻址1MB。

I386的保护模式支持分段机制，整个虚拟空间可以划分为16K个段，每个段大小可变，最大能达到4GB，每个段可以提供独立的段内保护，支持二级分页机制，每个页面4KB，提供段页式存储管理的硬件支持。同时，在同一个任务内部，还提供4种（0~3）保护特权级，某一级特权i只可以访问所有其他大于等于这一特权级（>=i）的程序段。

**I386中段页式管理的硬件支持**

在存储过程中，要经过相对独立的两级地址变换。第一级使用分段机制，把包含段地址和段内偏移地址的二维虚拟地址空间转换为一个线性地址空间（也是虚拟地址空间），第二级使用分页机制，把线性地址空间转换为物理地址空间。这种转换关系可以用下图描述。

![image](https://github.com/dj99fei/study/blob/master/os/images/9B57F39B-619F-4833-9C62-B322BC853797.png?raw=true)

线性地址（虚拟地址）是一个无符号的整数，比如8086cpu中它是个32位的无符号整数，可以表示高达4GB的地址。线性地址通常用16机制数字表示，8086cpu中值的范围从0x00000000到0xffffffff。

物理地址是用于内存芯片级内存单元寻址。它们与从cpu的地址引脚发送到内存总线上的电信号相对应。

内存控制单元（MMU）通过一种称为分段单元（segmentation unit）的硬件电路把一个逻辑地址转换为线性地址，接着，第二个称为分页单元（paging unit）的硬件电路把线性地址转换为一个物理地址。如下图

![image](https://github.com/dj99fei/study/blob/master/os/images/AB45F47D-FCD2-493D-8CA3-D5B206B7091A.png?raw=true)
